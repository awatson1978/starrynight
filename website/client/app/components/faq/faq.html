<template name="faq">
  <div id="faq" class="padded page">
    <p>
      <b>Q: Do you accept pull requests?</b><br>
      A: Yes.  We ask that the pull-requests be smallish and bite-sized chunks, so we can do code review, is all.
    </p>

    <p>
      <b>Q:  What's the difference between StarryNight and Nightwatch?</b><br>
      Nightwatch is a test-runner written in Node.  Meteor is a pipelining application written in Node.  StarryNight is an integration of Nightwatch with Meteor.
    </p>
    <p>
      <b>Q:  What's the difference between StarryNight/Nightwatch and Velocity?</b><br>
      Velocity is a package-based approach, that is unit-testing centric.  StarryNight/Nightwatch are Node applications on the same level as Meteor itself.  We prefer Nightwatch for various reasons related to encapsulation and continuous-integration.  If you're new to testing, Velocity is probably the tool you want to use.  If you have regulatory approval needs, StarryNight and Nightwatch are what you want to use.
    </p>

    <p>
      <b>Q:  How does testing packages with StarryNight work?</b><br>
      There are two ways we're experimenting with. The first is a scrape of the TinyTest runner, which is the same method that SpaceJam uses. TinyTest runs the package tests, but reports it to the browser console, which Nightwatch then reads.
      <br><br>
      The second method uses Nightwatch to do the unit testing for packages, and involves building a config file with the necessary directory paths in it. Building the config file is Meteor specific, and slightly outside the purview of Nightwatch (which is a Node end-to-end runner), which is what the StarryNight utility is for.
    </p>

    <p>
      <b>Q:  How do Nightwatch/Tinytest work together?</b><br>
      starrynight run-tests --framework tinytest-ci
      <br><br>
      There's also experimental support for running both Nightwatch and TinyTest in the same command. If you want to tinker with running them serially vs in parallel, the 'multi' framework is for that. Right now it's disabled, but it's in active development, so that's liable to change at any time.
      <br><br>
      starrynight run-tests --framework multi
    </p>

    <p>
      <b>Q:  Can I write my unit and integration tests within a package using Nightwatch (v0.6) syntax and have them run successfully?</b><br>
      Right now, you can write unit tests using Nightwatch syntax within the package, but not integration tests. This requires the StarryNight --autogenerate and --autogenerated flags. (In time, we'll link that process together so it's fully automated.)
      <br><br>
      For integration tests, you would need to add the --framework tinytest-ci argument, and pick up the TinyTest results from the console browser and report them via Nightwatch.
    </p>

    <p>
      <b>Q:  It looks like you're choosing to include lots of different syntaxes and frameworks after reading through some source code. Mocha, Jasmine, Cucumber syntax, etc. This makes me a little anxious.</b>
      <br>
      Yes, the intent is a complete integration of the different syntaxes. They each serve a different purpose, and from the discussions I've had with my clients, there's a need to have them all in one place without multiple packages. Now, keep in mind that most libraries only introduce a few novel syntaxes. describe/it syntax in Mocha; Given/Where/Then syntax in Cucumber; should.be.foo syntax in Chai Expect; verify.foo() method chaining in Nightwatch, etc. Each syntax is optimized for a different use: Mocha is great for unit tests, Cucumber for behavior-driven development, Nightwatch for test-driven-development, and so forth.
      <br><br>
      Beyond the syntactical differences, the remaining functionality in the various frameworks is a mish-mash of overlapping functionality. People reinventing the wheel with regard to runners and reporting. And that's where the bulk of the overhead comes from.
      <br><br>
      I've been in contact with Andrei, and he's expressed similar anxiety about including Mocha and Cucumber directly. Nightwatch already has a runner and a reporter, so why add Mocha's? It just creates redundancy in the code base. He proposed simply adding the describe/it syntax, and the Given/Where/Then syntax directly to Nightwatch. Which would provide the core API syntax that people find useful, but do it via a tight integration, and without the overhead of multiple libraries.
      <br><br>
      The idea right now seems to be that Mocha and Cucumber syntax will get precompiled down to Nightwatch's TDD syntax, in a similar way to how CoffeeScript gets compiled to Javascript, Stylus/Less gets compiled to CSS, and Jade gets compiled to HTML.
    </p>

    <p>
      <b>Q: I see in the generated nightwatch.json that tests can be run with phantomjs. How??</b><br>
      A:  starrynight run-tests --framework nightwatch --env phantomjs --autogenerated
    </p>
    <p>
      <b>Q: How do you pass --env to nightwatch?</b><br>
      A:  starrynight run-tests --framework nightwatch --env unittests --autogenerated
    </p>


  </div>
</template>
